# Goroutine vs 虚拟线程：简要对比

本文对比 Go 的 goroutine 与 Java 的虚拟线程（Virtual Threads）在特性、性能、实现、设计思路与使用成本上的差异，并说明 Go 选择 goroutine 的原因。

---

## 一、特性对比

| 维度 | Go goroutine | Java 虚拟线程（Virtual Threads） |
|------|----------------|-----------------------------------|
| **出现时间** | 语言诞生即有（2009） | JDK 19 Preview，21 正式（2023） |
| **定位** | 语言核心、唯一推荐的并发抽象 | 在现有线程模型上的扩展，与平台线程并存 |
| **创建方式** | `go f()`，语法级支持 | `Thread.ofVirtual().start(r)` 或 `ExecutorService` 用虚拟线程 |
| **默认行为** | 写 `go` 就是 goroutine，没有「平台线程」概念暴露给用户 | 默认仍是平台线程；要用虚拟线程需显式选 API |
| **调度器** | 内置 M:N（G 被 M 个 OS 线程执行），runtime 全管 | JVM 在用户态调度，挂载到少量平台线程（carrier），JVM 管 |
| **栈** | 初始约 2KB，按需增长/收缩 | 堆上分配、按需扩容，不占 OS 线程栈 |
| **与现有代码** | 无「老并发模型」，全是 goroutine | 老代码不变仍是平台线程；新/改代码才用虚拟线程 |
| **阻塞语义** | 阻塞 goroutine 只占少量内存，不阻塞 OS 线程 | 阻塞虚拟线程会「卸下」 carrier，不占 OS 线程，等价上类似 |

共同点：都是**轻量、数量可很大、面向「大量并发任务」**的抽象；从「一个请求/任务一个并发单元」的用法上很像。

---

## 二、性能（相对印象）

- **数量与内存**：两者都能轻松到几十万、百万级并发单元；单实例内存都远小于「百万 OS 线程」。Go 栈更小起步，Java 虚拟线程栈在 JVM 堆里，单条大致在 KB 级量级，都适合高并发。
- **调度与切换**：Go 的切换在用户态、无内核参与，成本低；Java 虚拟线程在挂起/恢复时会有 carrier 的 park/unpark 和可能的内核调用，但比真·平台线程切换轻很多。高并发、I/O 密集场景下两者都能做到很高吞吐。
- **谁更快**：强依赖场景和实现（网络库、GC、调度器调优等）。一般说法是：同风格使用时，两者都能把 I/O 密集服务压到接近「最优硬件利用」，差异多在生态和库是否「友好 goroutine/虚拟线程」，而不是原理上的代差。
- **CPU 密集**：Go 若一个 goroutine 占满一个 M，会拖慢同进程其他 goroutine；Java 虚拟线程同样，长时间占着 carrier 不释放会限制可调度数量。两者都建议 CPU 密集用工作池或单独拆分。

结论：**特性上都能支撑高并发，性能上都能做得很好；差异主要在设计与生态，而非「谁绝对更快」。**

---

## 三、实现思路对比

### Go

- **语言即并发**：`go` 是关键字，编译器/runtime 内置；没有「线程」作为用户可见的一等概念。
- **G–M–P 模型**：G（goroutine）、M（OS 线程）、P（逻辑 CPU/调度上下文）；M 绑定 P，P 上有 G 队列；M 阻塞时 P 可换到别的 M，G 可迁移。
- **协作式 + 抢占**：早期纯协作式（只在函数调用等点让出），后来加抢占（基于信号的异步抢占），避免一个 G 占死一个 M。
- **栈**：连续栈、分段增长/收缩，由 runtime 管理，和 C 的栈风格不同，不需要大块预分配。

### Java

- **在现有线程模型上叠一层**：`Thread` 仍是抽象，下面分「平台线程」（传统）和「虚拟线程」；API 尽量复用（同一个 `Thread`、`Runnable`、多数同步原语）。
- **Continuation + 调度**：Project Loom 引入 continuation（可挂起/恢复的执行体），虚拟线程就是「跑在 continuation 上的 Thread」；阻塞时 yield continuation、释放 carrier，就绪时再绑到某个 carrier 上跑。
- **透明挂起**：在大部分阻塞式 I/O（经 NIO 封装后）、`Thread.sleep`、`Lock.lock()` 等点，由 JVM 插入「挂起虚拟线程、放走 carrier」的逻辑；所以老代码换到虚拟线程后，往往不用改就能获得「大并发」。
- **栈**：虚拟线程栈是堆上的对象，可移动、可扩容，不占 OS 线程栈，所以能开很多。

**对比一句**：Go 从第一天就按 M:N 设计语言与 runtime；Java 是在已有「1 线程 = 1 平台线程」的世界上，用 continuation + 调度器模拟出「很多轻量 Thread」，实现「类似 goroutine 的用法」。

---

## 四、设计思路（为什么这样设计）

### Go：为什么用 goroutine

- **目标**：简化「高并发服务端」开发，避免回调地狱、也不必到处写线程池。
- **取舍**：用「一个连接/请求一个 goroutine」的直白模型，把调度和栈管理全部交给 runtime，让用户写同步代码就能得到高并发。
- **语言与 runtime 一体**：类型系统、内存模型、GC、调度器一起为 goroutine 服务；没有历史包袱，所以 goroutine 是唯一、默认的并发单元。
- **结果**：Go 的卖点之一就是「自带轻量并发」，适合 I/O 密集、多连接、微服务。

### Java：为什么是虚拟线程而不是重做语言

- **目标**：在不动现有 API 和生态的前提下，让「thread-per-request」、阻塞式写法能扩展到高并发，减少响应式/回调的改造量。
- **取舍**：保留 `Thread`、`synchronized`、`Lock`、大部分阻塞 API 的语义，在 JVM 里用虚拟线程+carrier 实现「阻塞不占 OS 线程」；因此实现复杂（continuation、栈移动、对 JDK 里阻塞点的改造），但兼容性好。
- **生态**：Spring、Tomcat、各种库不用大改，只需在「创建线程」的地方改用虚拟线程（或给 Executor 换虚拟线程工厂），就能显著提升并发能力。
- **结果**：不推翻「Java 线程」，而是让「线程」变轻，兼顾老代码和新项目。

**一句话**：Go 用 goroutine 定义「怎么并发」；Java 用虚拟线程在不改「线程」概念的前提下，把「线程」变轻，和 Go 在用法上对齐。

---

## 五、使用成本

### Go

- **学习**：理解 `go`、channel、不要共享内存而是通信，习惯后写起来简单。
- **心智**：没有线程、线程池、Executor 等概念，全是 goroutine；需要注意不要在单 goroutine 里做重 CPU 或阻塞 runtime。
- **坑**：循环里 `go` 闭包捕获变量、panic 未 recover 导致整进程挂、CGO 阻塞 M 等，需要一点经验。
- **生态**：标准库和主流库都是 goroutine 友好，第三方库质量参差。

### Java

- **迁移**：老项目「换虚拟线程」成本低：改线程池/线程创建方式、或加配置（如 Spring Boot 3.2+ 可配虚拟线程），多数业务代码不动。
- **心智**：仍要区分「平台线程」和「虚拟线程」（pin、synchronized 会 pin 住 carrier、native 调用等）；线程局部变量、锁的语义都在，要避免在虚拟线程里用不合适的用法（如大量 synchronized 独占 carrier）。
- **坑**：pin 导致 carrier 被占、部分 native 或老库阻塞 carrier、调试与观测和「线程」视图的对应关系要重新理解。
- **生态**：正在完善中，新 JDK 和框架会越来越友好；老库、反射、JNI 等需要时间逐步适配。

**对比**：Go 一开始就按 goroutine 设计，写新项目成本低、心智统一；Java 虚拟线程的「使用成本」主要在迁移与兼容，写新代码时若按「大量虚拟线程 + 阻塞式 I/O」来写，和 Go 的「一个请求一个 goroutine」的复杂度类似。

---

## 六、总结表

| 维度 | Goroutine | 虚拟线程 |
|------|-----------|----------|
| **特性** | 语言内置、唯一并发抽象、M:N、轻量栈 | 库/API 层、与平台线程并存、用户态调度、堆上栈 |
| **性能** | 极高并发、用户态切换、适合 I/O 密集 | 极高并发、阻塞不占 OS 线程、适合 I/O 密集 |
| **实现** | G-M-P、协作+抢占、连续栈 | Continuation、carrier、可移动堆栈、阻塞点插入 |
| **设计** | 「用 goroutine 做并发」为语言核心 | 「不砸烂线程模型，让线程变轻」 |
| **使用成本** | 学 Go 即学 goroutine，无迁移 | 老代码可低改动迁移，需理解 pin 与兼容边界 |
| **Go 为何用 goroutine** | 为简单、高并发服务端而设计，语言与 runtime 一体，无历史线程包袱 | — |

整体上：**goroutine 和虚拟线程在「轻量、大量、阻塞不占 OS 线程」上是对齐的；Go 用语言级 goroutine 定义了并发模型，Java 用虚拟线程在现有线程模型上复刻了类似的并发能力，并尽量压低使用和迁移成本。**

---

*可与本模块的 [JAVA_FEATURES.md](JAVA_FEATURES.md)、[JAVA_17_TO_21_FEATURES.md](JAVA_17_TO_21_FEATURES.md)、[JAVA_VS_OTHER_LANGUAGES.md](JAVA_VS_OTHER_LANGUAGES.md) 一并参阅。*
